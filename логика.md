# Логика работы приложения "Моё Настроение"

## Статус реализации

| Компонент | Статус | Описание |
|-----------|--------|----------|
| База данных НП | ✅ Готово | JSON файлы в `assets/districts/` |
| API чек-инов | ✅ Готово | POST, SYNC, DELETE эндпоинты |
| API рейтингов | ✅ Готово | Города, регионы, округа |
| API пользователей | ✅ Готово | Регистрация, получение профиля |
| Подсчет уникальных пользователей | ✅ Готово | `COUNT(DISTINCT user_id)` |
| Валидация userId | ✅ Готово | Обязательное поле |
| Офлайн-режим | ✅ Готово | Локальное хранение + синхронизация |
| Кэширование рейтингов | ⏳ Частично | Локальный кэш есть, серверный нет |
| Аутентификация | ❌ Не сделано | Нет JWT/токенов |
| Rate Limiting | ❌ Не сделано | Нет ограничений запросов |
| Push-уведомления | ❌ Не сделано | Напоминания о чек-ине |
| История чек-инов | ❌ Не сделано | Просмотр своей истории |
| Модерация НП | ❌ Не сделано | Проверка добавленных НП |

---

## Общая архитектура

### Распределение данных между фронтендом и бекендом

#### **Бекенд (обязательно хранить):** ✅ Реализовано
- ✅ **База данных всех населенных пунктов России** (города, села, деревни, поселки)
  - Хранится в JSON файлах в `assets/districts/` (на фронтенде)
  - Хранится в `backend/app/data/districts/` (на бекенде)
  - Содержит: ID, название, тип, население, регион, федеральный округ, район
  - **Почему на бекенде:** Это справочная информация, которая редко меняется и нужна для валидации

- ✅ **Все чек-ины пользователей**
  - Хранится в SQLite базе данных (`backend/data/happyrussia.db`)
  - Содержит: ID чек-ина, user_id, город, регион, настроение, дата
  - **Почему на бекенде:** Это критичные данные, которые должны быть централизованы для корректного подсчета статистики

- ✅ **Профили пользователей**
  - Таблица `users` в базе данных
  - Имя, номер телефона (ID пользователя), населенный пункт регистрации
  - **Почему на бекенде:** Для связи чек-инов с пользователями и предотвращения дублирования

- ✅ **Статистика и рейтинги**
  - Рассчитывается на бекенде на основе чек-инов
  - ⏳ Кэширование на сервере не реализовано

#### **Фронтенд (локальное хранилище):** ✅ Реализовано
- ✅ **Профиль пользователя** (кэш)
  - Имя, фото, местоположение, телефон
  - Хранится в `SharedPreferences` для быстрого доступа
  - **Почему на фронтенде:** Для офлайн-доступа и быстрой загрузки UI

- ✅ **Локальные чек-ины** (временное хранилище)
  - Сохраняются локально перед отправкой на сервер
  - Используются для синхронизации при отсутствии интернета
  - **Почему на фронтенде:** Для работы в офлайн-режиме

- ✅ **Кэш рейтингов**
  - Последние загруженные рейтинги для быстрого отображения
  - **Почему на фронтенде:** Для улучшения UX (мгновенная загрузка)

---

## API Эндпоинты

### Чек-ины (`/api/checkins`)

| Метод | Эндпоинт | Описание | Статус |
|-------|----------|----------|--------|
| POST | `/api/checkins` | Создать новый чек-ин | ✅ |
| POST | `/api/checkins/sync` | Синхронизация офлайн чек-инов | ✅ |
| DELETE | `/api/checkins/all` | Удалить все чек-ины (debug) | ✅ |
| GET | `/api/checkins/user/{user_id}` | История чек-инов пользователя | ❌ |

### Рейтинги (`/api/regions`, `/api/cities`)

| Метод | Эндпоинт | Описание | Статус |
|-------|----------|----------|--------|
| GET | `/api/regions/ranking` | Рейтинг всех регионов | ✅ |
| GET | `/api/regions/{region_id}/stats` | Статистика региона | ✅ |
| GET | `/api/regions/{region_id}/cities/ranking` | Рейтинг городов региона | ✅ |
| GET | `/api/regions/federal-districts/ranking` | Рейтинг федеральных округов | ✅ |
| GET | `/api/cities/ranking` | Рейтинг всех городов России | ✅ |
| GET | `/api/cities/{city_id}/districts/ranking` | Рейтинг районов города | ✅ |

### Пользователи (`/api/users`)

| Метод | Эндпоинт | Описание | Статус |
|-------|----------|----------|--------|
| POST | `/api/users` | Регистрация/обновление пользователя | ✅ |
| GET | `/api/users/{user_id}` | Получить профиль пользователя | ✅ |
| DELETE | `/api/users/{user_id}` | Удалить аккаунт пользователя | ❌ |

### Служебные

| Метод | Эндпоинт | Описание | Статус |
|-------|----------|----------|--------|
| GET | `/` | Информация об API | ✅ |
| GET | `/api/health` | Проверка здоровья API | ✅ |
| GET | `/docs` | Swagger документация | ✅ |

---

## Процесс регистрации пользователя

### 1. Регистрация ✅ Реализовано
1. Пользователь вводит:
   - Имя
   - Номер телефона (ID пользователя)
   - Выбирает населенный пункт проживания (через поиск или геолокацию)

2. Данные сохраняются:
   - **Локально** (SharedPreferences) - для быстрого доступа ✅
   - **На бекенде** (таблица `users`) ✅
   - Формат: `{name, phone, location: "Округ - Регион - Город"}`

3. Населенный пункт валидируется:
   - ✅ Проверяется наличие в базе данных бекенда
   - ❌ Если не найден - предлагается заполнить данные этого населенного пункта (НЕ РЕАЛИЗОВАНО)
   - Наименование, вид населенного пункта, район (если есть), регион, округ, количество населения
   - Сверить эти данные с данными РуВики и записать в базу данных

### 2. Связь пользователя с населенным пунктом ✅ Реализовано
- Пользователь привязывается к населенному пункту регистрации
- Эта информация используется для:
  - Отображения карточки города в профиле
  - Предзаполнения данных при чек-ине
  - Статистики по населенным пунктам

---

## Процесс голосования (чек-ин)

### 1. Создание чек-ина ✅ Реализовано
1. Пользователь выбирает:
   - Настроение (1-5, через смайлики)
   - Место чек-ина:
     - **"Место регистрации"** - населенный пункт из профиля
     - **"Текущее местоположение"** - определяется через GPS

2. Данные чек-ина:
   ```json
   {
     "id": "uuid",
     "userId": "+79999999999",  // Номер телефона из профиля (ОБЯЗАТЕЛЬНО)
     "regionId": "38",
     "regionName": "Иркутская область",
     "cityId": "38-0348",
     "cityName": "Иркутск",
     "mood": 5,
     "date": "2026-01-02T12:00:00Z",
     "federalDistrict": "Сибирский",
     "district": "Иркутский район"
   }
   ```

3. Отправка на бекенд:
   - ✅ Чек-ин сохраняется локально (для офлайн-режима)
   - ✅ Отправляется на бекенд через API
   - ✅ При успехе - удаляется из локального хранилища

### 2. Обработка множественных чек-инов одного пользователя ✅ Реализовано

#### **Ключевое правило:**
> **Один пользователь может голосовать много раз за день, но в статистике считается как ОДИН проголосовавший**

#### **Логика подсчета:**

1. **Количество проголосовавших (totalCheckIns):** ✅
   - Считается как **количество УНИКАЛЬНЫХ пользователей**, которые сделали хотя бы один чек-ин за период
   - **НЕ** количество всех чек-инов
   - Формула: `COUNT(DISTINCT user_id) WHERE date >= period_start`

2. **Среднее настроение (averageMood):** ✅
   - Если пользователь голосовал несколько раз за день:
     - Берется последний чек-ин за день
     - Затем считается среднее по всем пользователям

3. **Правила:**
   - ✅ Количество проголосовавших **НЕ уменьшается** (только увеличивается)
   - ✅ Количество проголосовавших может быть **больше населения** (люди путешествуют)
   - ✅ При первом чек-ине пользователя в городе - счетчик увеличивается на 1
   - ✅ При последующих чек-инах того же пользователя - счетчик **НЕ меняется**

### 3. Пример расчета

**Сценарий:**
- Город: Иркутск (население: 587,891)
- Пользователь 1 (+79991111111): голосовал 3 раза (5, 4, 5)
- Пользователь 2 (+79992222222): голосовал 1 раз (3)
- Пользователь 3 (+79993333333): голосовал 2 раза (5, 5)

**Результат:**
- `totalCheckIns = 3` (3 уникальных пользователя)
- `averageMood = (5 + 3 + 5) / 3 = 4.33` (берем последний чек-ин каждого пользователя)
- `happyPercentage = (3 / 587891) * 100 = 0.0005%`

---

## Подсчет статистики на бекенде ✅ Реализовано

### 1. Рейтинг городов

```python
def calculate_city_ranking(db: Session, period: str = "day"):
    # Получаем уникальных пользователей по городу за период
    unique_users = db.query(
        CheckInDB.city_id,
        CheckInDB.city_name,
        CheckInDB.region_id,
        CheckInDB.user_id,
        func.max(CheckInDB.mood).label('last_mood'),  # Последний чек-ин
        func.max(CheckInDB.date).label('last_date')
    ).filter(
        period_filter,
        CheckInDB.city_name.isnot(None),
        CheckInDB.user_id.isnot(None),  # Обязательно userId
        CheckInDB.user_id != ""
    ).group_by(
        CheckInDB.city_id,
        CheckInDB.city_name,
        CheckInDB.region_id,
        CheckInDB.user_id  # Группируем по пользователю
    ).all()
    
    # Группируем по городу и считаем статистику
    city_stats = {}
    for user in unique_users:
        city_key = (user.city_id, user.city_name)
        if city_key not in city_stats:
            city_stats[city_key] = {
                'users': set(),
                'moods': []
            }
        city_stats[city_key]['users'].add(user.user_id)
        city_stats[city_key]['moods'].append(user.last_mood)
    
    # Формируем результат
    rankings = []
    for (city_id, city_name), stats in city_stats.items():
        total_users = len(stats['users'])  # Количество уникальных пользователей
        avg_mood = sum(stats['moods']) / len(stats['moods'])
        
        rankings.append({
            "id": city_id,
            "name": city_name,
            "totalCheckIns": total_users,  # Количество уникальных пользователей
            "averageMood": round(avg_mood, 2),
            "population": get_city_population(city_id, city_name)
        })
    
    # Сортируем по среднему настроению (от большего к меньшему)
    rankings.sort(key=lambda x: x["averageMood"], reverse=True)
    return rankings
```

### 2. Рейтинг регионов ✅
Аналогично городам, но группировка по `region_id`:
- `totalCheckIns` = количество уникальных пользователей в регионе
- `averageMood` = среднее настроение всех уникальных пользователей

### 3. Рейтинг федеральных округов ✅
Аналогично, но группировка по `federal_district`:
- `totalCheckIns` = количество уникальных пользователей в округе
- `averageMood` = среднее настроение всех уникальных пользователей

---

## Сортировка рейтингов ✅ Реализовано

### Правила сортировки:

1. **Приоритет 1:** Наличие голосов
   - Населенные пункты с голосами всегда выше тех, у кого нет голосов

2. **Приоритет 2:** Среднее настроение (averageMood)
   - Среди населенных пунктов с голосами сортировка по убыванию `averageMood`
   - Чем выше настроение, тем выше в рейтинге

3. **Приоритет 3:** Население
   - Среди населенных пунктов без голосов сортировка по убыванию `population`
   - Более крупные города выше

### Алгоритм сортировки:

```dart
settlements.sort((a, b) {
  final aHasVotes = a.totalCheckIns > 0;
  final bHasVotes = b.totalCheckIns > 0;
  
  // Сначала с голосами
  if (aHasVotes && !bHasVotes) return -1;
  if (!aHasVotes && bHasVotes) return 1;
  
  // Оба с голосами - по настроению
  if (aHasVotes && bHasVotes) {
    return b.averageMood.compareTo(a.averageMood);
  }
  
  // Оба без голосов - по населению
  return b.population.compareTo(a.population);
});
```

---

## Хранение данных

### База данных на бекенде ✅ Реализовано

#### **Таблица: checkins**
```sql
CREATE TABLE checkins (
    id VARCHAR PRIMARY KEY,           -- UUID чек-ина
    user_id VARCHAR NOT NULL,         -- ID пользователя (номер телефона) - ОБЯЗАТЕЛЬНО
    region_id VARCHAR NOT NULL,       -- ID региона
    region_name VARCHAR NOT NULL,     -- Название региона
    city_id VARCHAR,                  -- ID города
    city_name VARCHAR,                -- Название города
    federal_district VARCHAR,         -- Федеральный округ
    district VARCHAR,                 -- Район
    mood INTEGER NOT NULL,            -- Настроение (1-5)
    date DATETIME NOT NULL,           -- Дата чек-ина
    created_at DATETIME               -- Время создания записи
);

-- Индексы для производительности
CREATE INDEX idx_user_date ON checkins(user_id, date);
CREATE INDEX idx_city_date ON checkins(city_id, date);
CREATE INDEX idx_region_date ON checkins(region_id, date);
```

#### **Таблица: users** ✅ Реализовано
```sql
CREATE TABLE users (
    user_id VARCHAR PRIMARY KEY,      -- Номер телефона
    name VARCHAR NOT NULL,            -- Имя пользователя
    registration_city_id VARCHAR,     -- ID города регистрации
    registration_city_name VARCHAR,   -- Название города регистрации
    registration_region_id VARCHAR,   -- ID региона
    registration_region_name VARCHAR, -- Название региона
    registration_federal_district VARCHAR, -- Федеральный округ
    created_at DATETIME               -- Дата регистрации
);
```

### Локальное хранилище (фронтенд) ✅ Реализовано

#### **SharedPreferences:**
- `profile_name` - имя пользователя
- `profile_phone` - номер телефона (ID пользователя)
- `profile_location` - местоположение регистрации
- `profile_image_path` - путь к фото профиля
- `check_ins` - список локальных чек-инов (для синхронизации)
- `regions_cache` - кэш рейтинга регионов
- `cities_cache` - кэш рейтинга городов

---

## Периоды статистики ✅ Реализовано

### Поддерживаемые периоды:

| Период | Описание | Фильтр |
|--------|----------|--------|
| `day` | За сегодня | `date >= начало дня` |
| `week` | За неделю | `date >= 7 дней назад` |
| `month` | За месяц | `date >= 30 дней назад` |

### Логика подсчета по периодам:
- `totalCheckIns` = уникальные пользователи **за выбранный период**
- `averageMood` = среднее настроение **за выбранный период**
- При переключении периода статистика пересчитывается

---

## Обработка офлайн-режима ✅ Реализовано

### 1. Создание чек-ина без интернета
- ✅ Чек-ин сохраняется локально в `SharedPreferences`
- ✅ При появлении интернета - автоматическая синхронизация
- ✅ Используется эндпоинт `/api/checkins/sync` для массовой отправки

### 2. Загрузка рейтингов
- ✅ Если нет интернета - показываются кэшированные данные
- ✅ При появлении интернета - автоматическое обновление

---

## Безопасность и валидация

### 1. Валидация данных ✅ Реализовано
- ✅ Проверка существования города в базе данных
- ✅ Проверка корректности ID региона
- ✅ Валидация настроения (1-5)
- ✅ Проверка обязательности `userId` (номер телефона)
- ⏳ Проверка формата номера телефона (частично)

### 2. Защита от дублирования ✅ Реализовано
- ✅ Проверка уникальности `user_id` при подсчете статистики
- ✅ Использование `COUNT(DISTINCT user_id)` вместо `COUNT(*)`

### 3. Аутентификация ❌ Не реализовано
- ❌ JWT токены
- ❌ Верификация номера телефона (SMS)
- ❌ Защита API от подмены `user_id`

### 4. Rate Limiting ❌ Не реализовано
- ❌ Ограничение запросов в минуту
- ❌ Ограничение чек-инов в день

### 5. Ограничения (текущие)
- ⚠️ Один пользователь может голосовать неограниченное количество раз
- ⚠️ Но в статистике считается только как один проголосовавший
- ⚠️ Нет защиты от спама (рекомендуется добавить лимит 10 чек-инов в час)

---

## Обработка ошибок

### Коды ошибок API

| Код | Описание | Пример |
|-----|----------|--------|
| 200 | Успешно | Данные получены |
| 201 | Создано | Чек-ин создан |
| 400 | Неверный запрос | `userId является обязательным полем` |
| 404 | Не найдено | `Регион не найден` |
| 422 | Ошибка валидации | Неверный формат данных |
| 500 | Ошибка сервера | Внутренняя ошибка |

### Обработка на фронтенде ✅ Реализовано
- ✅ Показ ошибок пользователю через `SnackBar`
- ✅ Retry при ошибках сети
- ✅ Fallback на кэш при недоступности сервера

---

## Производительность

### Оптимизация запросов ✅ Реализовано

1. **Индексы в базе данных:**
   - ✅ `(user_id, date)` - для быстрого поиска чек-инов пользователя
   - ✅ `(city_id, date)` - для быстрого расчета статистики города
   - ✅ `(region_id, date)` - для быстрого расчета статистики региона

2. **Кэширование:**
   - ✅ Локальный кэш на фронтенде для быстрой загрузки
   - ❌ Серверный кэш (TTL: 5 минут) - не реализовано

3. **Агрегация данных:**
   - ✅ Статистика рассчитывается при запросе
   - ✅ Используется `GROUP BY` для эффективной группировки

---

## План дальнейшей разработки

### Приоритет 1 (Критично)
- [ ] **Аутентификация** - JWT токены для защиты API
- [ ] **Верификация телефона** - SMS код при регистрации
- [ ] **Rate Limiting** - ограничение запросов

### Приоритет 2 (Важно)
- [ ] **История чек-инов** - просмотр своих голосований
- [ ] **Удаление аккаунта** - GDPR compliance
- [ ] **Серверное кэширование** - Redis для рейтингов

### Приоритет 3 (Улучшения)
- [ ] **Push-уведомления** - напоминание о чек-ине
- [ ] **Модерация НП** - проверка добавленных населенных пунктов
- [ ] **Статистика пользователя** - личный дашборд
- [ ] **Социальные функции** - поделиться настроением

---

## Итоговая схема работы

```
1. Регистрация ✅
   Пользователь → Выбор города → Сохранение в профиль (локально + бекенд)

2. Чек-ин ✅
   Пользователь → Выбор настроения → Выбор места → Отправка на бекенд
   
3. Подсчет статистики (на бекенде) ✅
   Все чек-ины → Фильтр по userId NOT NULL → Группировка по user_id 
   → Подсчет уникальных пользователей → Расчет среднего настроения 
   → Сортировка по averageMood
   
4. Отображение ✅
   Бекенд → API → Фронтенд → Отображение рейтингов
```

---

## Выводы

### Где хранить данные:

| Данные | Хранилище | Статус |
|--------|-----------|--------|
| База городов России | **Бекенд + Фронтенд** | ✅ |
| Все чек-ины | **Бекенд** | ✅ |
| Профили пользователей | **Бекенд + Локально** | ✅ |
| Рейтинги | **Бекенд (расчет) + Локально (кэш)** | ✅ |

### Ключевые принципы:

1. ✅ **Бекенд - источник истины** для всех данных
2. ✅ **Фронтенд - кэш** для быстрого доступа
3. ✅ **totalCheckIns = количество уникальных пользователей**, не всех чек-инов
4. ✅ **Количество проголосовавших не уменьшается**
5. ✅ **Сортировка: сначала по наличию голосов, потом по averageMood**
6. ✅ **userId (номер телефона) - обязательное поле**

### Что реализовано:
- ✅ Полный цикл чек-ина (создание, отправка, статистика)
- ✅ Рейтинги городов, регионов, округов
- ✅ Подсчет уникальных пользователей
- ✅ Офлайн-режим с синхронизацией
- ✅ Профили пользователей
- ✅ Валидация обязательных полей

### Что нужно доработать:
- ❌ Аутентификация и безопасность
- ❌ Rate Limiting
- ❌ История чек-инов пользователя
- ❌ Push-уведомления
- ❌ Серверное кэширование
